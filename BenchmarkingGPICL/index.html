<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">google.load("jquery", "1.3.2");</script>

<style type="text/css">
	body {
		font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
		font-weight:300;
		font-size:18px;
		margin-left: auto;
		margin-right: auto;
		width: 1100px;
	}

	h1 {
		font-size:32px;
		font-weight:300;
	}

	.disclaimerbox {
		background-color: #eee;
		border: 1px solid #eeeeee;
		border-radius: 10px ;
		-moz-border-radius: 10px ;
		-webkit-border-radius: 10px ;
		padding: 20px;
	}

	video.header-vid {
		height: 140px;
		border: 1px solid black;
		border-radius: 10px ;
		-moz-border-radius: 10px ;
		-webkit-border-radius: 10px ;
	}

	img.header-img {
		height: 140px;
		border: 1px solid black;
		border-radius: 10px ;
		-moz-border-radius: 10px ;
		-webkit-border-radius: 10px ;
	}

	img.rounded {
		border: 1px solid #eeeeee;
		border-radius: 10px ;
		-moz-border-radius: 10px ;
		-webkit-border-radius: 10px ;
	}

	a:link,a:visited
	{
		color: #1367a7;
		text-decoration: none;
	}
	a:hover {
		color: #208799;
	}

	td.dl-link {
		height: 160px;
		text-align: center;
		font-size: 22px;
	}

	.layered-paper-big { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
		box-shadow:
		0px 0px 1px 1px rgba(0,0,0,0.35), /* The top layer shadow */
		5px 5px 0 0px #fff, /* The second layer */
		5px 5px 1px 1px rgba(0,0,0,0.35), /* The second layer shadow */
		10px 10px 0 0px #fff, /* The third layer */
		10px 10px 1px 1px rgba(0,0,0,0.35), /* The third layer shadow */
		15px 15px 0 0px #fff, /* The fourth layer */
		15px 15px 1px 1px rgba(0,0,0,0.35), /* The fourth layer shadow */
		20px 20px 0 0px #fff, /* The fifth layer */
		20px 20px 1px 1px rgba(0,0,0,0.35), /* The fifth layer shadow */
		25px 25px 0 0px #fff, /* The fifth layer */
		25px 25px 1px 1px rgba(0,0,0,0.35); /* The fifth layer shadow */
		margin-left: 10px;
		margin-right: 45px;
	}

	.paper-big { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
		box-shadow:
		0px 0px 1px 1px rgba(0,0,0,0.35); /* The top layer shadow */

		margin-left: 10px;
		margin-right: 45px;
	}


	.layered-paper { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
		box-shadow:
		0px 0px 1px 1px rgba(0,0,0,0.35), /* The top layer shadow */
		5px 5px 0 0px #fff, /* The second layer */
		5px 5px 1px 1px rgba(0,0,0,0.35), /* The second layer shadow */
		10px 10px 0 0px #fff, /* The third layer */
		10px 10px 1px 1px rgba(0,0,0,0.35); /* The third layer shadow */
		margin-top: 5px;
		margin-left: 10px;
		margin-right: 30px;
		margin-bottom: 5px;
	}

	.vert-cent {
		position: relative;
		top: 50%;
		transform: translateY(-50%);
	}

	hr
	{
		border: 0;
		height: 1px;
		background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
	}
</style>

<html>
<head>
<h1> 
	<title>Benchmarking General Purpose In-Context Learning </title>
	<meta property="og:image" content="https://github.com/FutureAGI/futureagi.github.io/blob/main/BenchmarkingGPICL/imgs/HTML_ICL.png"/> 
	<meta property="og:title" content="通用上下文学习及其训练和评测." />
	<meta property="og:description" content="低的零样本泛化能力，长上下文学习周期，高上下文学习天花板 - 通向通用上下文学习和通用人工智能" />

	<!-- Get from Google Analytics -->
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src=""></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-75863369-6');
	</script>
</head>

<body>
	<br>
	<center>
		<span style="font-size:36px">通用上下文学习及其训练和评测</span><br>
		<span style="font-size:24px">Benchmarking General Purpose In-Context Learning</span>
		<table align=center width=850px>
			<tr>
				<td>
	            <center>
				<strong style="color: red; font-weight: bold;">授AI以鱼，不如授AI以渔</strong>
				</td>
			</tr>
		</table>
		<table align=center width=600px>
			<table align=center width=250px>
				<tr>
					<td align=center width=120px>
						<center>
							<span style="font-size:24px"><a href='https://arxiv.org/abs/2405.17234'>[Paper]</a></span>
						</center>
					</td>
					<td align=center width=120px>
						<center>
							<span style="font-size:24px"><a href='https://github.com/FutureAGI/L3C'>[Code]</a></span><br>
						</center>
					</td>
				</tr>
			</table>
		</table>
	</center>

<hr>
<div style="text-align: center;">
    <video width="100%" controls autoplay loop muted>
        <source src="imgs/demo_wm_10.mp4" type="video/mp4">
        World Modeling with Maze World simulator: the upper section is the ground truth, the lower section is the prediction
    </video>
</div>
<br>

<table align=center width=850px>
<center><h1>什么是通用上下文学习？为什么要强调它？</h1></center>
<tr>
<td>
我们认为， 大模型智能涌现的核心能力包括两方面<br>
<ul>  
    <li><strong style="color: red; font-weight: bold;">零样本泛化</strong> （Zero-shot Generalization）: 模型具有将其所有训练过的数据和知识，记忆在参数空间，并利用上述知识，进行推理泛化解决问题。</li>  
    <li><strong style="color: red; font-weight: bold;">小样本上下文学习</strong> （Few-shot In-Context Learning）: 模型更进一步，具有通过提示（Prompt）信息，掌握在训练时，完全没有见过的数据/技能。</li>  
</ul>


上下文学习通常具有一些很好的性质，包括极少样本（相比梯度下降少得多的样本）就能学习一项新技能；对学习方式不敏感，很多时候不必给正样本，用提示信息告诉模型什么是错的，也能辅助学习。即可以包罗传统意义上的监督学习，强化学习，无监督学习；对噪音不敏感，提示中包含不清晰的地方，依旧可以正确执行，这使得模型具有泛化到非常广泛的任务的潜力。<br><br>

然而，当前的上下文学习还存在明显局限性：包括上下文学习的样本量通常不是很多（通常是少量示例）。而且上下文学习通常被限制在“指令跟随”级别，而无法在上下文内，做反复尝试和优化的复杂过程（如强化学习）。此外，尽管近期以来，大模型能够编码的上下文长度在不断增长，需要看到很多上下文编码不是真正的“学习”过程。大部分是偏简单的复制，召回特定内容等任务。<br><br>

<center>
    <table align=center width=850px>
    <tr>
    <td width=260px>
    <center>
    <img class="round" style="width:100%" src="./imgs/HTML_GPICL.png" alt="通用上下文学习定义及其和其他学习方法区别"/>
    <p class="caption">通用上下文学习定义及其和其他学习方法区别</p>
    </center>
    </td>
    </tr>
    </table>
</center>

我们认为，为了实现真正的通用人工智能，有必要将上下文学习扩展到通用上下文学习（General Purpose In-Context Learning， GPICL）。相对于其他方法，GPICL具有如下显著特征<br>

<ul>  
  <li><strong style="color: red; font-weight: bold;">低的零样本泛化能力</strong>（Low Zero-shot Generalization）.</li>  
  <li><strong style="color: red; font-weight: bold;">长上下文学习周期</strong>（Long In-Context Learning Horizon）.</li>  
  <li><strong style="color: red; font-weight: bold;">高上下文学习天花板</strong>（High In-Context Learning Potential）.</li>  
</ul>

尽管提升上下文学习的上限和长度已经是大家共识，但降低零样本能力作为目标较为反直觉，其中原因是什么？ 
我们认为，零样本泛化能力和数据的多样性成反向关系：零样本泛化能力越强恰恰越证明训练模型所使用的训练样本和训练任务的多样性有限，而使得模型保留了过多任务或者任务范围相关的知识，但这进一步限制了模型的泛化到任务范围外的能力。
为此，我们认为，合适的任务集合，是帮助AI学习到通用上下文学习能力的关键。
所以，降低零样本泛化能力的目标不在于对于一个固定的训练集，我们需要让模型尽可能学不到样本中的知识；
而在于<strong style="color: red; font-weight: bold;">我们需要采用尽可能多样的训练集，这种多样性足以使模型无法对任务学习到任何预先的假设</strong>。

</td>
</tr>

<table align=center width=850px>
<center><h1>通用上下文学习评测集的要求</h1></center>
<tr>
<td>
基于上述原因，我们认为，建立适合于通用上下文学习（GPICL）的训练和评测任务集非常重要。通用上下文学习顾名思义，可以泛化更广的未见任务，甚至包括不同模态，而不要求这些任务或者模态在预训练（Pre-training, 或者元训练 Meta-training）时被见过。具体的，我们认为通用上下文学习需要满足几个标准：
<ul>  
  <li><strong style="color: red; font-weight: bold;">任务数量和任务多样性足够大</strong>，
          以至于任何模型不能从任务集中学习到任何可用的零样本泛化知识。如果任务数量多但多样性不够大，模型很容易学到高的零样本泛化能力，但上下文学习的潜力和必要性不强，但对于任务集外的任务可能泛化行就欠缺。如果任务多样性足够大，但数量不够多，则模型容易陷入“多任务学习”+ “任务辨识”的陷阱。即：模型尝试在预训练时，把所有任务完成方式和特点“记忆”下来，推理时，仅仅需要很少上下文去做“任务辨识”，就足以很好完成任务。这两种都不会引导模型学习真正的GPICL能力。</li>  
  <li><strong style="color: red; font-weight: bold;">终生上下文学习</strong>（Lifelong In-Context Learning），模型需要依赖足够长的上下文，不是两三个，也不是二三十个样本，而是数百万计，甚至数十亿计的上下文，才能完全掌握任务。这里的上下文长度，是在“理想的学习方法”下，最小的上下文长度。</li>  
  <li><strong style="color: red; font-weight: bold;">持续的生成和交互</strong>。上下文是通过实时不断生成和交互产生的持续性的样本。</li>  
</ul>
</td>
</tr>

<table align=center width=850px>
<center><h1>元语言(Meta-Language)生成器</h1></center>
<tr>
<td>
我们认为，相比于学习具体的，自然的语言，学习一种新的语言的过程符合GPICL的需求。然而，世界上常用的语言不过数百种，如果将自然语言的学习本身作为样本，其数量过于稀少。因此，一种理想的方式是创造近乎无数种类的“语言”。每个“语言”是一个超长序列的样本。模型通过上下文可以学会一种新的语言。我们提出一种“创造”这种新“语言”的方式，是用随机参数的网络，来生成随机的序列。这种随机的序列在相对较短的时候没有任何意义。但随着这个序列不断延长，生成该序列的内在规律可以被外部捕捉到。这种无限的“新语言”的序列，是GPICL理想的试验场。<br><br>
我们发现，Transformer模型可以捕捉这种随机序列而产生上下文学习能力。我们证明，这种上下文学习能力是一种通用的上下文学习能力。因为模型不单单能通过上下文掌握一种新的随机序列，我们将用随机序列预训练模型用于真正的自然语言任务，发现它仍然具有学习能力。注意模型完全没有使用任何自然语言序列进行学习。
</td>
</tr>

<center>
    <table align=center width=850px>
    <tr>
    <td width=260px>
    <center>
    <img class="round" style="width:100%" src="./imgs/MetaLM_Scaling_Law.png" alt="元语言模型在不同复杂度的元语言上的评测效果"/>
    <p class="caption"> 元语言模型在不同复杂度的元语言上的评测效果，最后PG-19是一个自然语言评测集。
            模型的表现随着上下文长度的增加而变好，即便是没有训练过的自然语言亦是如此，证明元语言训练具有很好的泛用性。
            此外，几千万参数的模型继续Scaling Up对效果并没有帮助。证明GPICL不是总需要巨大的参数量。</p>
    <img class="round" style="width:60%" src="./imgs/Demo_Eng.png" alt="英语演示"/>
    <p class="caption">元语言模型具备利用上下文学习完全未知数据的能力。这里元语言模型学习英文单词。模型能够捕捉英文单词的规律。</p>
    <img class="round" style="width:60%" src="./imgs/Demo_Math.png" alt="数学演示"/>
    <p class="caption">元语言模型具备利用上下文学习完全未知数据的能力。这里元语言模型学习数学等式。模型能够捕捉数学等式的规律。</p>
    </center>
    </td>
    </tr>
    </table>
</center>

</body>
</html>


<table align=center width=850px>
<center><h1>迷宫世界(Maze World)生成和模拟</h1></center>
<tr>
<td>
迷宫世界是一个规则明确，但多样性又足够显著的轻量级仿真环境。在迷宫世界中，可以轻易定制大小，结构，墙面完全不同的迷宫。在这个仿真环境中，我们设置了导航（NAVIGATION）和生存（SURVIVAL）两类任务。以导航任务为例，我们在迷宫中会随机加入多样的，一定数量的“地标”。这些标志随机产生在一个随机迷宫的不同位置。对于一个智能体，我们的环境会产生随机的指令，要求智能体尽快抵达特定颜色的地标。这要求智能体能够探索、记忆、定位、寻径，高效达成任务。且对于任何一个任务，因为迷宫和地标都是完全随机的，智能体除了依赖于自己探索，没有任何方式知道有关迷宫的任何先验信息。<br><br>
除了环境本身，考虑强化学习一般较难规模化，我们提供了可供模型进行模仿学习从而快速热启动的“标杆智能体”。这类标杆智能体可以直接访问全局地图，但全局地图是有限制的，即它们必须先看到过才能记录下来。这类标杆智能体可以产生大量高质量的数据，供模型学习直接模仿。<br><br>
我们的实验结果证明，使用Transformer结构进行上下文学习，具备“世界模型”（World Model）和“策略模型”（Policy Model）进行同时上下文学习的能力（据我们了解，这是第一个观察到世界模型ICL的工作），但当前实验结果也表明，当前模型离理想状态（如较好的标杆智能体）还有比较大差距，因此也存在巨大的优化空间。
</td>
</tr>

<center>
    <table align=center width=850px>
    <tr>
    <td width=260px>
    <center>
    <img class="round" style="width:100%" src="./imgs/MazeWorld_Explanation.png" alt="迷宫世界环境和标杆智能体的地图记忆说明"/>
    <p class="caption">迷宫世界环境和标杆智能体的地图记忆说明</p>
    <img class="round" style="width:100%" src="./imgs/Fig_MazeWorldModel.png" alt="世界模型和策略模型一体的迷宫导航模型"/>
    <p class="caption">世界模型和策略模型一体的迷宫导航模型</p>
    <img class="round" style="width:100%" src="./imgs/WM_PM_Decay.png" alt="评测中世界模型和策略模型显示出随着上下文变长的自适应能力"/>
    <p class="caption">评测中世界模型和策略模型显示出随着上下文变长的自适应能力</p>
    <img class="round" style="width:100%" src="./imgs/World_Modeling.png" alt="利用上下文学习的世界模型在未来预测上变得越来越准确"/>
    <p class="caption">利用上下文学习的世界模型在未来预测上变得越来越准确</p>
    </center>
    </td>
    </tr>
    </table>
</center>


<table align=center width=850px>
<center><h1>增加参数量还是增加记忆和上下文？</h1></center>
<tr>
<td>
上述两个环境，尽管我们上下文学习长度都只做到2K到4K, 我们可以通过修改配置，将上下文学习的最短长度扩展到百万甚至数十亿以上。我们相信，这类评测训练集对于长上下文学习，以及通用上下文学习具有重要意义。此外，尽管两个环境相对较简单也较轻量，但具有较大的研究意义。元语言目标是训练具有语言学习和适应能力的通用智能体，而迷宫的目标是具有未知环境的探索、定位、导航能力一体的通用具身智能体。

此外，我们的工作也应证了之前很多工作的发现：<strong style="color: red; font-weight: bold;">上下文学习能力和模型参数规模具有很弱的关联</strong>（在模型参数超过一定阈值后， 其上下文学习能力不再增加），而和上下文，以及记忆状态的规模存在正向的强关联。这给我们揭示一条不同于直接暴力增加参数规模的道路：足够大的参数 + 大量记忆和上下文知识。

基于此，我们还提出不同于当前大语言模型的一种新的可能的训练方法：通过海量的合成数据，训练通用上下文学习的能力。再通过小规模的高质量数据，对齐模型和人类的偏好。这和自然智能的产生更为相似： 前者对应几十亿年生命进化，后者则对应人类个体的一生。

<center>
    <table align=center width=850px>
    <tr>
    <td width=260px>
    <center>
    <img class="round" style="width:100%" src="./imgs/GPICL_Pipeline.png" alt="通用上下文学习主导的大模型训练流程说明"/>
    <p class="caption">通用上下文学习主导的大模型训练流程说明</p>
    </center>
    </td>
    </tr>
    </table>
</center>

</body>
</html>
